use std::str::FromStr;

use lalrpop_util::ParseError;

grammar;

pub CommaSepInt32s = Comma<Int32>;

Comma<T>: Vec<T> = {
  <mut v:(<T> ",")*> <e:T> => { v.push(e); v }
}

Int32: i32 = {
  r"[0-9]+" =>? i32::from_str(<>)
    .map_err(|_| ParseError::User {
      error: "Number can't be parsed"
    })
};

// 2021 Day 8 puzzle input
use crate::signals_from_day8::{Signal, Puzzle};

pub Puzzle: Puzzle = {
  <transients:(Signal)+> "|" <readout:(Signal)+> => (transients, readout)
}

Signal: Signal = {
  r"[a-g]+" => <>.chars().collect()
}

// 2021 Day 5: `x,y -> x2,y2`
use crate::coordinates::{Coord, Line};

pub Line2d: Line = {
  <s:Coord2d> "->" <e:Coord2d> => Line::new(s, e)
}

Coord2d: Coord = {
  <x:Int32> "," <y:Int32> => Coord::new(x, y, 0)
}

use crate::rps::{Play, Outcome};
pub RpsHand: (Play, Play) = {
  Play Play => (<>)
}

pub RpsHandOutcome: (Play, Outcome) = {
  Play Outcome => (<>)
}

// For some reason I can't get regex to work for these at all,
// so I have extra literals
Play: Play = {
  // r"[AX]" => Play::Rock, // This rule can't match the X in "A X"
  "A" => Play::Rock,
  "X" => Play::Rock,
  "B" => Play::Paper,
  "Y" => Play::Paper,
  "C" => Play::Scissors,
  "Z" => Play::Scissors,
}

Outcome: Outcome = {
  "X" => Outcome::Lose,
  "Y" => Outcome::Draw,
  "Z" => Outcome::Win
}
